/*
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.api.kotlin.generator

import com.google.api.kotlin.GeneratorContext
import com.google.api.kotlin.config.FlattenedMethod
import com.google.api.kotlin.config.PagedResponse
import com.google.api.kotlin.config.PropertyPath
import com.google.api.kotlin.config.ProtobufTypeMapper
import com.google.api.kotlin.config.SampleMethod
import com.google.api.kotlin.config.asPropertyPath
import com.google.api.kotlin.config.merge
import com.google.common.base.CaseFormat
import com.google.protobuf.DescriptorProtos
import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.TypeName
import com.squareup.kotlinpoet.asTypeName
import org.apache.commons.text.WordUtils
import javax.annotation.Generated

// line wrapping helper
internal fun String?.wrap(wrapLength: Int = 100) = if (this != null) {
    WordUtils.wrap(this, wrapLength)
} else {
    null
}

internal fun CodeBlock.indent(level: Int): CodeBlock {
    val builder = CodeBlock.builder()
    repeat(level) { builder.indent() }
    builder.add(this)
    repeat(level) { builder.unindent() }
    return builder.build()
}

/**
 * The result of a flattened method with the given [config] including the [parameters]
 * for the method declaration and the [requestObject] that should be passed to the
 * underlying (original) method.
 */
internal data class FlattenedMethodResult(
    val parameters: List<ParameterInfo>,
    val requestObject: CodeBlock,
    val config: FlattenedMethod
)

/**
 * A wrapper for a ParameterSpec that includes type information if the parameter is
 * from a flattened method and the path that it was referenced from.
 */
internal data class ParameterInfo(
    val spec: ParameterSpec,
    val flattenedPath: PropertyPath? = null,
    val flattenedFieldInfo: ProtoFieldInfo? = null
)

/**
 * Various reusable generator logic and extensions for [DescriptorProtos].
 *
 * @author jbolinger
 */
internal abstract class AbstractGenerator {

    /** Create a "generated by" annotation. */
    protected fun createGeneratedByAnnotation() =
        AnnotationSpec.builder(Generated::class)
            .addMember("%S", this::class.qualifiedName ?: "")
            .build()

    /**
     * Get info about a proto field at the [path] of given [type].
     *
     * For direct properties of the type the path is should contain 1 element (the
     * name of the field). For nested properties more than 1 element can be given.
     */
    protected fun getProtoFieldInfoForPath(
        context: GeneratorContext,
        path: PropertyPath,
        type: DescriptorProtos.DescriptorProto
    ): ProtoFieldInfo {
        // find current field
        val (name, idx) = "(.+)\\[([0-9])+]".toRegex().matchEntire(path.firstSegment)
            ?.destructured?.let { (n, i) -> Pair(n, i.toInt()) }
            ?: Pair(path.firstSegment, -1)

        val field = type.fieldList.firstOrNull { it.name == name }
            ?: throw IllegalStateException("cannot find field '$name' within path: $path found: ${type.fieldList.map { it.name }}")

        // only support for 0 index is implemented, so bail out if greater
        if (idx > 0) {
            throw IllegalArgumentException(
                "using a non-zero field index is not supported: $path"
            )
        }

        // if no nesting, we're done
        if (path.size == 1) {
            val kotlinType = field.asClassName(context.typeMap)
            return ProtoFieldInfo(context.proto, type, field, idx, kotlinType)
        }

        if (context.typeMap.hasProtoTypeDescriptor(field.typeName)) {
            val t = context.typeMap.getProtoTypeDescriptor(field.typeName)
            return getProtoFieldInfoForPath(context, path.subPath(1, path.size), t)
        }
        throw IllegalStateException("Type could not be traversed: ${field.typeName}")
    }

    /** Get the real response type for an LRO operation */
    protected fun getLongRunningResponseType(
        ctx: GeneratorContext,
        method: DescriptorProtos.MethodDescriptorProto
    ): ClassName {
        // TODO: there is no guarantee that this will always hold,
        //       but there isn't any more info in the proto (yet)
        val name = method.inputType.replace("Request\\z".toRegex(), "Response")
        if (name == method.inputType) throw IllegalStateException("Unable to determine Operation response type")
        return ctx.typeMap.getKotlinType(name)
    }

    /** Get the type of element in a paged result list */
    protected fun getResponseListElementType(
        ctx: GeneratorContext,
        method: DescriptorProtos.MethodDescriptorProto,
        paging: PagedResponse
    ): ClassName {
        val outputType = ctx.typeMap.getProtoTypeDescriptor(method.outputType)
        val info = getProtoFieldInfoForPath(ctx, paging.responseList.asPropertyPath(), outputType)
        return info.field.asClassName(ctx.typeMap)
    }

    /**
     * A [builder] CodeBlock that can construct an proto object as a Kotlin type
     * along with it's corresponding [parameters].
     */
    protected data class BuilderCodeBlock(
        val parameters: List<ParameterInfo>,
        val builder: CodeBlock
    )

    /**
     * Get a builder CodeBlock for constructing the [messageType] via it's [kotlinType]
     * with the given [propertyPaths] setters filled out.
     *
     * If [sample] is non-null and it contains a property path that matches an entry in
     * [propertyPaths] it's value is used for the setter. Otherwise, the property name
     * is used as the variable name given to the setter.
     */
    protected fun getBuilder(
        context: GeneratorContext,
        messageType: DescriptorProtos.DescriptorProto,
        kotlinType: TypeName,
        propertyPaths: List<PropertyPath>,
        sample: SampleMethod? = null
    ): BuilderCodeBlock {
        // params for the method signature
        lateinit var parameters: List<ParameterInfo>

        // the set of builders to be used to create the request object
        val builders = mutableMapOf<String, CodeBlockBuilder>()

        // add outermost builder
        val code = CodeBlock.builder()
            .add("%T {\n", kotlinType)
            .indent()

        this.visitType(context, messageType, propertyPaths.merge(sample), object : Visitor() {
            override fun onBegin(params: List<ParameterInfo>) {
                parameters = params
            }

            override fun onTerminalParam(currentPath: PropertyPath, fieldInfo: ProtoFieldInfo) {
                // check if an explicit value was set for this property
                // if not use the parameter name
                val explicitValue = sample?.parameters?.find {
                    it.parameterPath == currentPath.toString()
                }
                val value = explicitValue?.value ?: getParameterName(fieldInfo.field.name)

                // set value or add to appropriate builder
                val setterCode = getSetterCode(context.typeMap, fieldInfo, value, true)
                if (currentPath.size == 1) {
                    code.addStatement("%L", setterCode)
                } else {
                    val key = currentPath.takeSubPath(currentPath.size - 1).toString()
                    builders[key]!!.code.addStatement("%L", setterCode)
                }
            }

            override fun onNestedParam(currentPath: PropertyPath, fieldInfo: ProtoFieldInfo) {
                // create a builder for this param, if first time
                val key = currentPath.toString()
                if (!builders.containsKey(key)) {
                    val nestedBuilder = CodeBlock.builder()
                        .add(
                            "%T {\n",
                            context.typeMap.getKotlinType(fieldInfo.field.typeName)
                        )
                        .indent()
                    builders[key] = CodeBlockBuilder(nestedBuilder, fieldInfo)
                }
            }

            override fun onEnd() {
                // close the nested builders
                builders.forEach { path, builder ->
                    builder.code
                        .add("}\n")
                        .unindent()
                }

                // build from innermost to outermost
                builders.keys.map { it.split(".") }.sortedBy { it.size }.reversed()
                    .map { it.asPropertyPath() }
                    .forEach { currentPath ->
                        val builder = builders[currentPath.toString()]!!
                        code.add(
                            getSetterCode(
                                context.typeMap, builder.fieldInfo, builder.code.build(), true
                            )
                        )
                    }
            }
        })

        // close outermost builder
        code.unindent().add("}")

        return BuilderCodeBlock(parameters, code.build())
    }

    private class CodeBlockBuilder(
        val code: CodeBlock.Builder,
        val fieldInfo: ProtoFieldInfo
    )

    /**
     * Kotlin Poet doesn't handle indented code within Kdoc well so we use this to
     * correct the indentations for sample code. It would be nice to find an alternative.
     */
    protected fun indentBuilder(context: GeneratorContext, code: CodeBlock, level: Int): CodeBlock {
        val indent = " ".repeat(level * 4)

        // we will get the fully qualified names when turning the code block into a string
        val specialPackages = "(${context.className.packageName}|com.google.api)"

        // remove fully qualified names and adjust indent
        val formatted = code.toString()
            .replace("\n", "\n$indent")
            .replace("^[ ]*$specialPackages\\.".toRegex(), "")
            .replace(" = $specialPackages\\.".toRegex(), " = ")
        return CodeBlock.of("%L", formatted)
    }

    /** Get the parameters to flatten the [method] using the given [config] and [context]. */
    protected fun getFlattenedParameters(
        context: GeneratorContext,
        method: DescriptorProtos.MethodDescriptorProto,
        config: FlattenedMethod
    ): FlattenedMethodResult {
        val protoType = context.typeMap.getProtoTypeDescriptor(method.inputType)
        val kotlinType = context.typeMap.getKotlinType(method.inputType)
        val (parameters, requestObj) = getBuilder(context, protoType, kotlinType, config.parameters)
        return FlattenedMethodResult(parameters, requestObj, config)
    }

    protected fun visitFlattenedMethod(
        context: GeneratorContext,
        method: DescriptorProtos.MethodDescriptorProto,
        parametersAsPaths: List<PropertyPath>,
        visitor: Visitor
    ) = visitType(
        context,
        context.typeMap.getProtoTypeDescriptor(method.inputType),
        parametersAsPaths,
        visitor
    )

    protected abstract class Visitor {
        open fun onBegin(params: List<ParameterInfo>) {}
        open fun onEnd() {}
        open fun onNestedParam(currentPath: PropertyPath, fieldInfo: ProtoFieldInfo) {}
        open fun onTerminalParam(currentPath: PropertyPath, fieldInfo: ProtoFieldInfo) {}
    }

    protected fun visitType(
        context: GeneratorContext,
        requestType: DescriptorProtos.DescriptorProto,
        parametersAsPaths: List<PropertyPath>,
        visitor: Visitor
    ) {
        // create parameter list
        val parameters = parametersAsPaths.map { path ->
            val fieldInfo = getProtoFieldInfoForPath(context, path, requestType)
            val rawType = fieldInfo.field.asClassName(context.typeMap)
            val typeName = when {
                fieldInfo.field.isMap(context.typeMap) -> {
                    val (keyType, valueType) = fieldInfo.field.describeMap(context.typeMap)
                    Map::class.asTypeName().parameterizedBy(
                        keyType.asClassName(context.typeMap),
                        valueType.asClassName(context.typeMap)
                    )
                }
                fieldInfo.field.isRepeated() -> List::class.asTypeName().parameterizedBy(rawType)
                else -> rawType
            }
            val spec = ParameterSpec.builder(getParameterName(path.lastSegment), typeName).build()
            ParameterInfo(spec, path, fieldInfo)
        }
        visitor.onBegin(parameters)

        // go through the nested properties from left to right
        val maxWidth = parametersAsPaths.map { it.size }.max() ?: 0
        for (i in 1..maxWidth) {
            // terminal node - set the value
            parametersAsPaths.filter { it.size == i }.forEach { path ->
                val currentPath = path.subPath(0, i)
                val field = getProtoFieldInfoForPath(context, path, requestType)

                visitor.onTerminalParam(currentPath, field)
            }

            // non terminal - ensure a builder exists
            parametersAsPaths.filter { it.size > i }.forEach { path ->
                val currentPath = path.subPath(0, i)
                val fieldInfo = getProtoFieldInfoForPath(context, currentPath, requestType)

                visitor.onNestedParam(currentPath, fieldInfo)
            }
        }

        visitor.onEnd()
    }

    /*
     * Create setter code based on type of field (map vs. repeated, vs. single object) using
     * the Java builder for the type.
     */
    protected fun getSetterCode(
        typeMap: ProtobufTypeMapper,
        fieldInfo: ProtoFieldInfo,
        value: CodeBlock,
        useDSLBuilder: Boolean
    ): CodeBlock {
        // use implicit this in dsl builders
        val qualifier = if (useDSLBuilder) {
            ""
        } else {
            "."
        }

        // map and repeated fields
        if (fieldInfo.field.isMap(typeMap)) {
            return CodeBlock.of(
                "$qualifier${getSetterMapName(fieldInfo.field.name, value)}(%L)",
                value
            )
        } else if (fieldInfo.field.isRepeated()) {
            return if (fieldInfo.index >= 0) {
                CodeBlock.of(
                    "$qualifier${getSetterRepeatedAtIndexName(fieldInfo.field.name, value
                    )}(${fieldInfo.index}, %L)",
                    value
                )
            } else {
                CodeBlock.of(
                    "$qualifier${getSetterRepeatedName(fieldInfo.field.name, value)}(%L)",
                    value
                )
            }
        }

        // normal fields
        return if (useDSLBuilder) {
            CodeBlock.of("${getAccessorName(fieldInfo.field.name, value)} = %L", value)
        } else {
            CodeBlock.of("$qualifier${getSetterName(fieldInfo.field.name, value)}(%L)", value)
        }
    }

    protected fun getSetterCode(
        typeMap: ProtobufTypeMapper,
        fieldInfo: ProtoFieldInfo,
        value: String,
        useDSLBuilder: Boolean
    ) =
        getSetterCode(typeMap, fieldInfo, CodeBlock.of("%L", value), useDSLBuilder)

    protected fun getAccessorName(typeMap: ProtobufTypeMapper, fieldInfo: ProtoFieldInfo): String {
        if (fieldInfo.field.isMap(typeMap)) {
            return getAccessorMapName(fieldInfo.field.name)
        } else if (fieldInfo.field.isRepeated()) {
            return if (fieldInfo.index >= 0) {
                "${getAccessorRepeatedAtIndexName(fieldInfo.field.name)}[${fieldInfo.index}]"
            } else {
                getAccessorRepeatedName(fieldInfo.field.name)
            }
        }
        return getAccessorName(fieldInfo.field.name)
    }

    protected fun getSetterMapName(protoFieldName: String, value: CodeBlock? = null) =
        "putAll" + CaseFormat.LOWER_UNDERSCORE.to(CaseFormat.UPPER_CAMEL, protoFieldName)

    protected fun getSetterRepeatedName(protoFieldName: String, value: CodeBlock? = null) =
        "addAll" + CaseFormat.LOWER_UNDERSCORE.to(CaseFormat.UPPER_CAMEL, protoFieldName)

    protected fun getSetterRepeatedAtIndexName(protoFieldName: String, value: CodeBlock? = null) =
        "add" + CaseFormat.LOWER_UNDERSCORE.to(CaseFormat.UPPER_CAMEL, protoFieldName)

    protected fun getSetterName(protoFieldName: String, value: CodeBlock? = null) =
        "set" + CaseFormat.LOWER_UNDERSCORE.to(CaseFormat.UPPER_CAMEL, protoFieldName)

    protected fun getAccessorMapName(protoFieldName: String, value: CodeBlock? = null) =
        CaseFormat.LOWER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL, protoFieldName) + "Map"

    protected fun getAccessorName(protoFieldName: String, value: CodeBlock? = null) =
        getQualifier(protoFieldName, value) + CaseFormat.LOWER_UNDERSCORE.to(
            CaseFormat.LOWER_CAMEL,
            protoFieldName
        ) + ""

    protected fun getAccessorRepeatedAtIndexName(protoFieldName: String, value: CodeBlock? = null) =
        getQualifier(protoFieldName, value) + CaseFormat.LOWER_UNDERSCORE.to(
            CaseFormat.LOWER_CAMEL,
            protoFieldName
        ) + ""

    protected fun getAccessorRepeatedName(protoFieldName: String, value: CodeBlock? = null) =
        getQualifier(protoFieldName, value) + CaseFormat.LOWER_UNDERSCORE.to(
            CaseFormat.LOWER_CAMEL,
            protoFieldName
        ) + "List"

    protected fun getParameterName(protoFieldName: String, value: CodeBlock? = null) =
        getQualifier(protoFieldName, value) + CaseFormat.LOWER_UNDERSCORE.to(
            CaseFormat.LOWER_CAMEL,
            protoFieldName
        ) + ""

    protected fun getQualifier(protoFieldName: String, value: CodeBlock? = null): String {
        val name = CaseFormat.LOWER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL, protoFieldName)
        return if (name == value.toString()) {
            "this."
        } else {
            ""
        }
    }
}
